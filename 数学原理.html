<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harris角点检测器数学原理详解</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #2980b9;
            margin-top: 30px;
        }
        h3 {
            color: #3498db;
        }
        .step {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .code-block {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            margin: 15px 0;
        }
        .formula {
            text-align: center;
            margin: 20px 0;
            font-size: 1.2em;
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }
        .math-explanation {
            background-color: #e7f3ff;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 20px 0;
        }
        .matrix {
            display: inline-block;
            margin: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .derivation {
            background-color: #fff8e1;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
        }
        .comparison {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        .comparison-item {
            flex: 1;
            min-width: 300px;
            margin: 10px;
        }
        .image-container {
            text-align: center;
            margin: 20px 0;
        }
        .image-container img {
            max-width: 100%;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px;
        }
        .highlight {
            background-color: #fffacd;
            padding: 2px 4px;
            border-radius: 3px;
        }
    </style>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <h1>Harris角点检测器数学原理详解</h1>

    <div class="step">
        <h2>1. 基础概念</h2>
        
        <p>Harris角点检测器基于图像局部窗口内的灰度变化。对于图像中的某个点(x,y)，我们考虑一个局部窗口，当窗口在各个方向上移动时，观察窗口内灰度变化的情况。</p>
        
        <div class="formula">
            灰度变化函数: \( E(u,v) = \sum_{x,y} w(x,y) [I(x+u,y+v) - I(x,y)]^2 \)
        </div>
        
        <div class="math-explanation">
            <p><strong>解释：</strong></p>
            <ul>
                <li>\( I(x,y) \)：图像在点(x,y)处的灰度值</li>
                <li>\( (u,v) \)：窗口移动的位移向量</li>
                <li>\( w(x,y) \)：窗口函数（通常是高斯函数）</li>
                <li>\( E(u,v) \)：窗口移动(u,v)后的灰度变化总和</li>
            </ul>
        </div>
    </div>

    <div class="step">
        <h2>2. 泰勒展开近似</h2>
        
        <p>对灰度变化函数进行一阶泰勒展开近似：</p>
        
        <div class="formula">
            \( I(x+u,y+v) \approx I(x,y) + uI_x(x,y) + vI_y(x,y) \)
        </div>
        
        <p>其中 \( I_x \) 和 \( I_y \) 是图像在x和y方向的梯度。</p>
        
        <p>代入灰度变化函数：</p>
        
        <div class="formula">
            \( E(u,v) \approx \sum_{x,y} w(x,y) [uI_x + vI_y]^2 \)
        </div>
        
        <div class="formula">
            \( E(u,v) \approx \sum_{x,y} w(x,y) [u^2I_x^2 + 2uvI_xI_y + v^2I_y^2] \)
        </div>
        
        <div class="formula">
            \( E(u,v) \approx Au^2 + 2Cuv + Bv^2 \)
        </div>
        
        <div class="math-explanation">
            <p><strong>其中：</strong></p>
            <ul>
                <li>\( A = \sum w(x,y) I_x^2 \)</li>
                <li>\( B = \sum w(x,y) I_y^2 \)</li>
                <li>\( C = \sum w(x,y) I_xI_y \)</li>
            </ul>
        </div>
    </div>

    <div class="step">
        <h2>3. 结构张量（H矩阵）</h2>
        
        <p>将灰度变化函数写成矩阵形式：</p>
        
        <div class="formula">
            \( E(u,v) \approx [u,v] M \begin{bmatrix} u \\ v \end{bmatrix} \)
        </div>
        
        <div class="formula">
            其中 \( M = \begin{bmatrix} A & C \\ C & B \end{bmatrix} = \begin{bmatrix} \sum w I_x^2 & \sum w I_xI_y \\ \sum w I_xI_y & \sum w I_y^2 \end{bmatrix} \)
        </div>
        
        <p>矩阵M称为结构张量或H矩阵，它描述了图像局部区域的梯度分布。</p>
        
        <div class="math-explanation">
            <p><strong>代码对应部分：</strong></p>
            <div class="code-block">
# 计算梯度乘积
Ix2 = Ix**2
Iy2 = Iy**2
Ixy = Ix * Iy

# 使用高斯窗口平滑
s_x2 = cv2.GaussianBlur(Ix2, (kernel_size, kernel_size), 0)
s_y2 = cv2.GaussianBlur(Iy2, (kernel_size, kernel_size), 0)
s_xy = cv2.GaussianBlur(Ixy, (kernel_size, kernel_size), 0)
            </div>
            <p>这里计算的就是H矩阵的元素：</p>
            <ul>
                <li>s_x2 对应 \( A = \sum w I_x^2 \)</li>
                <li>s_y2 对应 \( B = \sum w I_y^2 \)</li>
                <li>s_xy 对应 \( C = \sum w I_xI_y \)</li>
            </ul>
        </div>
    </div>

    <div class="step">
        <h2>4. 特征值分析</h2>
        
        <p>H矩阵的特征值 \( \lambda_1 \) 和 \( \lambda_2 \) 反映了图像局部区域的特性：</p>
        
        <div class="comparison">
            <div class="comparison-item">
                <h4>平坦区域</h4>
                <p>\( \lambda_1 \approx 0, \lambda_2 \approx 0 \)</p>
                <p>所有方向的灰度变化都很小</p>
            </div>
            <div class="comparison-item">
                <h4>边缘区域</h4>
                <p>\( \lambda_1 \gg 0, \lambda_2 \approx 0 \)</p>
                <p>一个方向变化大，垂直方向变化小</p>
            </div>
            <div class="comparison-item">
                <h4>角点区域</h4>
                <p>\( \lambda_1 \gg 0, \lambda_2 \gg 0 \)</p>
                <p>所有方向的变化都很大</p>
            </div>
        </div>
        
        <div class="image-container">
            <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6e/Harris_Stephens_Corner_Detection_Graph.svg/600px-Harris_Stephens_Corner_Detection_Graph.svg.png" alt="Harris特征值分析">
            <p>Harris特征值分析示意图</p>
        </div>
    </div>

    <div class="step">
        <h2>5. Harris响应函数</h2>
        
        <p>为了避免直接计算特征值，Harris提出了以下响应函数：</p>
        
        <div class="formula">
            \( R = \det(M) - k \cdot \text{trace}(M)^2 \)
        </div>
        
        <p>其中：</p>
        <div class="formula">
            \( \det(M) = \lambda_1 \lambda_2 = AB - C^2 \)
        </div>
        
        <div class="formula">
            \( \text{trace}(M) = \lambda_1 + \lambda_2 = A + B \)
        </div>
        
        <p>因此响应函数可以写为：</p>
        
        <div class="formula">
            \( R = (AB - C^2) - k(A + B)^2 \)
        </div>
        
        <div class="math-explanation">
            <p><strong>代码对应部分：</strong></p>
            <div class="code-block">
# 计算H矩阵的行列式和迹
det_H = s_x2 * s_y2 - s_xy**2
trace_H = s_x2 + s_y2

# 计算Harris响应
R = det_H - k * (trace_H**2)
            </div>
            <p>这里：</p>
            <ul>
                <li>det_H 对应 \( \det(M) = AB - C^2 \)</li>
                <li>trace_H 对应 \( \text{trace}(M) = A + B \)</li>
                <li>R 对应Harris响应值</li>
            </ul>
        </div>
        
        <div class="derivation">
            <h4>响应函数的推导</h4>
            <p>考虑特征值的性质：</p>
            <div class="formula">
                \( R = \lambda_1 \lambda_2 - k(\lambda_1 + \lambda_2)^2 \)
            </div>
            <p>对于角点：\( \lambda_1 \gg 0, \lambda_2 \gg 0 \)，所以 \( R \gg 0 \)</p>
            <p>对于边缘：\( \lambda_1 \gg 0, \lambda_2 \approx 0 \)，所以 \( R \approx -k\lambda_1^2 < 0 \)</p>
            <p>对于平坦区域：\( \lambda_1 \approx 0, \lambda_2 \approx 0 \)，所以 \( R \approx 0 \)</p>
        </div>
    </div>

    <div class="step">
        <h2>6. 梯度计算（Sobel算子）</h2>
        
        <p>Sobel算子通过卷积计算图像的近似梯度：</p>
        
        <div class="formula">
            \( I_x = I * S_x = I * \begin{bmatrix} -1 & 0 & 1 \\ -2 & 0 & 2 \\ -1 & 0 & 1 \end{bmatrix} \)
        </div>
        
        <div class="formula">
            \( I_y = I * S_y = I * \begin{bmatrix} -1 & -2 & -1 \\ 0 & 0 & 0 \\ 1 & 2 & 1 \end{bmatrix} \)
        </div>
        
        <p>其中 * 表示卷积操作。</p>
        
        <div class="math-explanation">
            <p><strong>代码对应部分：</strong></p>
            <div class="code-block">
# 计算x和y方向的梯度
Ix = cv2.Sobel(gray_image, cv2.CV_64F, 1, 0, ksize=kernel_size)
Iy = cv2.Sobel(gray_image, cv2.CV_64F, 0, 1, ksize=kernel_size)
            </div>
        </div>
    </div>

    <div class="step">
        <h2>7. 高斯平滑</h2>
        
        <p>高斯函数用于对梯度乘积进行加权平均：</p>
        
        <div class="formula">
            \( G(x,y) = \frac{1}{2\pi\sigma^2} e^{-\frac{x^2+y^2}{2\sigma^2}} \)
        </div>
        
        <p>对梯度乘积进行高斯平滑：</p>
        
        <div class="formula">
            \( A = I_x^2 * G \)
        </div>
        
        <div class="formula">
            \( B = I_y^2 * G \)
        </div>
        
        <div class="formula">
            \( C = I_xI_y * G \)
        </div>
        
        <div class="math-explanation">
            <p><strong>代码对应部分：</strong></p>
            <div class="code-block">
# 使用高斯窗口对梯度乘积进行求和
s_x2 = cv2.GaussianBlur(Ix2, (kernel_size, kernel_size), 0)
s_y2 = cv2.GaussianBlur(Iy2, (kernel_size, kernel_size), 0)
s_xy = cv2.GaussianBlur(Ixy, (kernel_size, kernel_size), 0)
            </div>
        </div>
    </div>

    <div class="step">
        <h2>8. 后处理数学原理</h2>
        
        <h3>8.1 阈值处理</h3>
        <div class="formula">
            \( \text{角点候选} = \{ (x,y) | R(x,y) > T \} \)
        </div>
        <p>其中T是预设的阈值。</p>
        
        <h3>8.2 非极大值抑制(NMS)</h3>
        <p>对于每个局部窗口，只保留响应值最大的点：</p>
        <div class="formula">
            \( \text{最终角点} = \{ (x,y) | R(x,y) = \max_{ (i,j) \in W(x,y) } R(i,j) \} \)
        </div>
        <p>其中 \( W(x,y) \) 是以(x,y)为中心的局部窗口。</p>
        
        <div class="math-explanation">
            <p><strong>代码对应部分：</strong></p>
            <div class="code-block">
# 非极大值抑制 (NMS)
for y in range(0, h - window_size, window_size):
    for x in range(0, w - window_size, window_size):
        window = R[y:y+window_size, x:x+window_size]
        if window.size == 0:
            continue
        max_val = window.max()
        if max_val > threshold:
            # 寻找最大值在窗口内的相对位置
            max_loc_rel = np.unravel_index(window.argmax(), window.shape)
            # 计算最大值在原图的绝对位置
            max_loc_abs = (y + max_loc_rel[0], x + max_loc_rel[1])
            
            # 确保该点是该窗口唯一的最大值
            if R[max_loc_abs] == max_val:
                corners.append(max_loc_abs)
            </div>
        </div>
    </div>

    <div class="step">
        <h2>9. 旋转不变性数学解释</h2>
        
        <p>Harris角点检测器具有旋转不变性，这是因为：</p>
        
        <div class="formula">
            \( M' = R M R^T \)
        </div>
        
        <p>其中R是旋转矩阵，M是原始结构张量，M'是旋转后的结构张量。</p>
        
        <p>由于特征值在旋转下不变：</p>
        
        <div class="formula">
            \( \det(M') = \det(R M R^T) = \det(M) \)
        </div>
        
        <div class="formula">
            \( \text{trace}(M') = \text{trace}(R M R^T) = \text{trace}(M) \)
        </div>
        
        <p>因此Harris响应函数R在旋转下保持不变：</p>
        
        <div class="formula">
            \( R' = \det(M') - k \cdot \text{trace}(M')^2 = \det(M) - k \cdot \text{trace}(M)^2 = R \)
        </div>
        
        <div class="math-explanation">
            <p>这就是为什么Harris角点检测器能够检测到相同的物理角点，无论图像如何旋转。</p>
        </div>
    </div>

    <div class="step">
        <h2>10. 完整的数学流程总结</h2>
        
        <ol>
            <li><strong>梯度计算：</strong>
                <div class="formula">
                    \( I_x = I * S_x, \quad I_y = I * S_y \)
                </div>
            </li>
            <li><strong>结构张量构建：</strong>
                <div class="formula">
                    \( M = \begin{bmatrix} I_x^2 * G & I_xI_y * G \\ I_xI_y * G & I_y^2 * G \end{bmatrix} \)
                </div>
            </li>
            <li><strong>响应函数计算：</strong>
                <div class="formula">
                    \( R = \det(M) - k \cdot \text{trace}(M)^2 \)
                </div>
            </li>
            <li><strong>角点判定：</strong>
                <div class="formula">
                    \( \text{角点} = \{ (x,y) | R(x,y) > T \text{ 且 } R(x,y) \text{ 是局部最大值} \} \)
                </div>
            </li>
        </ol>
        
        <div class="math-explanation">
            <p>这个数学框架解释了为什么Harris角点检测器能够有效地识别图像中的角点，同时抑制边缘和平坦区域的响应。</p>
        </div>
    </div>
</body>
</html>